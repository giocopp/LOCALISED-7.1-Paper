# Set working directory
setwd("/Users/giocopp/Desktop/LOCALISED-7.1-Paper/Pipeline_2-Vulnerability/Finance")

### Install Necessary Packages ###
remotes::install_github("eurostat/restatapi")

libs <- c(
  "restatapi",
  "tidyverse",
  "giscoR",
  "sf",
  "classInt",
  "mice",
  "visdat",
  "VIM"
)

installed_libs <- libs %in% rownames(
  installed.packages()
)

if (any(installed_libs == FALSE)) {
  install.packages(
    libs[!installed_libs],
    dependencies = TRUE
  )
}

invisible(
  lapply(
    libs, library,
    character.only = TRUE
  )
)

### GET DATA
### 
### Eurostat data
### 
### Gross investment in intangible goods
### 

indicator_df <- restatapi::get_eurostat_data(
  id = "sbs_ovw_iep",
  filters = c("SLS_TINV_MEUR", "GRSINV_NTNCA_XGWL_MEUR", "BE", "BG", "CZ", "DK", "DE", "EE", "IE", "EL", "ES", "FR", "HR", "IT", "CY", "LV", "LT", "LU", "HU", "MT", "NL", "AT", "PL", "PT", "RO", "SI", "SK", "FI", "SE", "C", "C10", "C11", "C12", "C13", "C14", "C15", "C16", "C17", "C18", "C19", "C20", "C21", "C22", "C23", "C24", "C25", "C26", "C27", "C28", "C29", "C30", "C31", "C32", "C33"), 
  date_filter = c(2022, 2021),
  exact_match = T,
  label = F,
  cflags = T,
  keep_flags = T,
)

indicator_df_f <- indicator_df |> 
  dplyr::rename(
    "NUTS_ID" = "geo",
    "Investment_Type" = "indic_sbs",
    "Values" = "values",
    "Sector" = "nace_r2",
    "Year" = "time"
  ) |> 
  dplyr::select(NUTS_ID, Sector, Year, Investment_Type, Values)

Eurostat_Tang <- indicator_df_f |> 
  dplyr::filter(Investment_Type == "SLS_TINV_MEUR") |> 
  dplyr::select(-Investment_Type)

Eurostat_Intang <- indicator_df_f |> 
  dplyr::filter(Investment_Type == "GRSINV_NTNCA_XGWL_MEUR") |> 
  dplyr::select(-Investment_Type)

# Impute missing 2022 values with previous year
Eurostat_Tang <- Eurostat_Tang |> 
  dplyr::group_by(NUTS_ID, Sector) |> 
  dplyr::mutate(
    Values = case_when(
      # Impute missing 2023 values using 2022 or 2021
      Year == 2022 & is.na(Values) ~ coalesce(
        Values[Year == 2021 & !is.na(Values)][1]
      ),
      # Impute missing 2022 values using 2021
      Year == 2022 & is.na(Values) ~ Values[Year == 2021 & !is.na(Values)][1],
      # Keep existing values for other cases
      TRUE ~ Values
    )
  ) |> 
  dplyr::ungroup()

# Step 3: Retain only rows for 2023 and drop the Year column
Eurostat_Tang <- Eurostat_Tang |> 
  dplyr::filter(Year == 2022) |> 
  dplyr::select(-Year)

# EU Avg if there are still NAs
sector_eu_avg <- Eurostat_Tang |> 
  dplyr::group_by(Sector) |> 
  dplyr::summarize(
    EU_Avg = mean(Values, na.rm = TRUE),  # Calculate the EU average per sector
    .groups = "drop"
  )

# Step 2: Replace NAs in the `Values` column with the sector EU average
Eurostat_Tang <- Eurostat_Tang |> 
  dplyr::left_join(sector_eu_avg, by = "Sector") |>  # Join to get EU averages
  dplyr::mutate(
    Values = ifelse(is.na(Values), EU_Avg, Values)  # Replace NAs with EU average
  ) |> 
  dplyr::select(-EU_Avg)

###
###

Eurostat_Intang <- Eurostat_Intang |> 
  dplyr::group_by(NUTS_ID, Sector) |> 
  dplyr::mutate(
    Values = case_when(
      # Impute missing 2023 values using 2022 or 2021
      Year == 2022 & is.na(Values) ~ coalesce(
        Values[Year == 2021 & !is.na(Values)][1]
      ),
      # Impute missing 2022 values using 2021
      Year == 2022 & is.na(Values) ~ Values[Year == 2021 & !is.na(Values)][1],
      # Keep existing values for other cases
      TRUE ~ Values
    )
  ) |> 
  dplyr::ungroup()

# Step 3: Retain only rows for 2023 and drop the Year column
Eurostat_Intang <- Eurostat_Intang |> 
  dplyr::filter(Year == 2022) |> 
  dplyr::select(-Year)

# EU Avg if there are still NAs
sector_eu_avg <- Eurostat_Intang |> 
  dplyr::group_by(Sector) |> 
  dplyr::summarize(
    EU_Avg = mean(Values, na.rm = TRUE),  # Calculate the EU average per sector
    .groups = "drop"
  )

# Step 2: Replace NAs in the `Values` column with the sector EU average
Eurostat_Intang <- Eurostat_Intang |> 
  dplyr::left_join(sector_eu_avg, by = "Sector") |>  # Join to get EU averages
  dplyr::mutate(
    Values = ifelse(is.na(Values), EU_Avg, Values)  # Replace NAs with EU average
  ) |> 
  dplyr::select(-EU_Avg)

### Adapt the Sectors
### Step 1: Create a mapping table for aggregation
sector_mapping <- data.frame(
  Original_Sector = c("C", "C10", "C11", "C12", "C13", "C14", "C15", "C16", "C17", "C18", "C19", "C20", "C21", "C22", "C23", "C24", "C25", "C26", "C27", "C28", "C29", "C30", "C31", "C32", "C33"),
  Aggregated_Sector = c("C", "C10-C12", "C10-C12", "C10-C12", "C13-C15", "C13-C15", "C13-C15", "C16-C18", "C16-C18", "C16-C18", "C19-C22", "C19-C22", "C19-C22", "C19-C22", "C23", "C24", "C25+C28-C30", "C26-C27", "C26-C27", "C25+C28-C30", "C25+C28-C30", "C25+C28-C30", "C31-C32", "C31-C32", "C33")
)

### Step 2: Map the original sectors to the aggregated sectors
Eurostat_Tang <- Eurostat_Tang |>
  left_join(sector_mapping, by = c("Sector" = "Original_Sector"))

Eurostat_Intang <- Eurostat_Intang |>
  left_join(sector_mapping, by = c("Sector" = "Original_Sector"))

### Step 3: Aggregate data by NUTS_ID, Stk_Flow, and Aggregated_Sector
Eurostat_Tang <- Eurostat_Tang |>
  group_by(NUTS_ID, Aggregated_Sector) |>
  summarise(
    Aggregated_Values = sum(Values, na.rm = TRUE),
    .groups = "drop"
  )

Eurostat_Intang <- Eurostat_Intang |>
  group_by(NUTS_ID, Aggregated_Sector) |>
  summarise(
    Aggregated_Values = sum(Values, na.rm = TRUE),
    .groups = "drop"
  )

### France is entirely missing in Intang: we use EU sectoral averages

# Step 1: Calculate EU averages for each sector (excluding France)
eu_averages <- Eurostat_Intang %>%
  filter(NUTS_ID != "FR") %>%
  group_by(Aggregated_Sector) %>%
  summarise(EU_Avg_Intang = mean(Aggregated_Values, na.rm = TRUE), .groups = "drop")

# Step 2: Extract missing sectors for France
missing_france <- Eurostat_Tang %>%
  filter(NUTS_ID == "FR") %>%
  select(NUTS_ID, Aggregated_Sector)

# Step 3: Join with EU averages to create new rows for France
france_imputed <- missing_france %>%
  left_join(eu_averages, by = "Aggregated_Sector") %>%
  rename(Aggregated_Values = EU_Avg_Intang)

# Step 4: Append imputed data to Eurostat_Intang
Eurostat_Intang <- Eurostat_Intang %>%
  bind_rows(france_imputed)

### Step 4: Rename columns for clarity
Eurostat_Tang <- Eurostat_Tang |>
  rename(Sector = Aggregated_Sector) |> 
  rename(Tang_Inv = Aggregated_Values)

Eurostat_Intang <- Eurostat_Intang |>
  rename(Sector = Aggregated_Sector) |> 
  rename(Intang_Inv = Aggregated_Values)

### Normalize min max
normalize_min_max_special <- function(data, 
                                      sector_col = "Sector", 
                                      tang_col = "Tang_Inv", 
                                      intang_col = "Intang_Inv", 
                                      total_sector = "C") {
  # Identify rows corresponding to the total sector and sub-sectors
  is_total_sector <- data[[sector_col]] == total_sector
  is_subsector <- startsWith(data[[sector_col]], total_sector) & !is_total_sector
  
  # Function to normalize a specific column
  normalize_column <- function(column, is_total_sector, is_subsector) {
    # Extract values for total sector and sub-sectors
    total_values <- column[is_total_sector]
    subsector_values <- column[is_subsector]
    
    # Compute min and max for the total sector
    min_total <- min(total_values, na.rm = TRUE)
    max_total <- max(total_values, na.rm = TRUE)
    
    # Compute min and max for all sub-sectors combined
    min_sub <- min(subsector_values, na.rm = TRUE)
    max_sub <- max(subsector_values, na.rm = TRUE)
    
    # Normalize values for the total sector
    column[is_total_sector] <- (column[is_total_sector] - min_total) / (max_total - min_total)
    
    # Normalize values for the sub-sectors
    column[is_subsector] <- (column[is_subsector] - min_sub) / (max_sub - min_sub)
    
    return(column)
  }
  
  # Normalize Tang_Inv column
  if (!is.null(tang_col) && tang_col %in% names(data)) {
    data[[tang_col]] <- normalize_column(data[[tang_col]], is_total_sector, is_subsector)
  }
  
  # Normalize Intang_Inv column
  if (!is.null(intang_col) && intang_col %in% names(data)) {
    data[[intang_col]] <- normalize_column(data[[intang_col]], is_total_sector, is_subsector)
  }
  
  return(data)
}

Eurostat_Tang_n <- normalize_min_max_special(Eurostat_Tang, sector_col = "Sector", tang_col = "Tang_Inv", total_sector = "C")

Eurostat_Intang_n <- normalize_min_max_special(Eurostat_Intang, sector_col = "Sector", intang_col = "Intang_Inv", total_sector = "C")

###
###

base_data <- readxl::read_excel("/Users/giocopp/Desktop/LOCALISED-7.1-Paper/Base Data/base_data_plus.xlsx") |> select(1:3)

# Non-normalized dataset
Eurostat_Fin <- base_data |> 
  dplyr::left_join(Eurostat_Tang, by = c("CNTR_CODE" = "NUTS_ID")) |> 
  dplyr::left_join(Eurostat_Intang, by = c("CNTR_CODE" = "NUTS_ID", "Sector")) |> 
  dplyr::select(-NUTS_NAME) |> 
  dplyr::rename(Sector_ID = Sector) |>
  dplyr::filter(nchar(NUTS_ID) != 2)

# Normalized dataset
Eurostat_Fin_n <- base_data |> 
  dplyr::left_join(Eurostat_Tang_n, by = c("CNTR_CODE" = "NUTS_ID")) |> 
  dplyr::left_join(Eurostat_Intang_n, by = c("CNTR_CODE" = "NUTS_ID", "Sector")) |> 
  dplyr::select(-NUTS_NAME) |> 
  dplyr::rename(Sector_ID = Sector) |>
  dplyr::filter(nchar(NUTS_ID) != 2)

### SAVE
# Save each dataset to an Excel file
writexl::write_xlsx(Eurostat_Fin, "Outputs/Data/Eurostat_Fin.xlsx")
writexl::write_xlsx(Eurostat_Fin_n, "Outputs/Data/Eurostat_Fin_n.xlsx")

###
### GFCF
### 

indicator_df <- restatapi::get_eurostat_data(
  id = "nama_10r_2gfcf",
  filters = c("MIO_EUR", "C"), 
  date_filter = c(2021),
  exact_match = T,
  label = F,
  cflags = T,
  keep_flags = T,
)

indicator_df_f <- indicator_df |> 
  dplyr::rename(
    "NUTS_ID" = "geo",
    "GFCF" = "values",
    "Year" = "time"
  ) |> 
  dplyr::select(NUTS_ID, GFCF)

base_data <- readxl::read_excel("/Users/giocopp/Desktop/LOCALISED-7.1-Paper/Base Data/base_data_plus.xlsx") |> 
  select(1:3)

Eurostat_GFCF <- base_data |> 
  dplyr::left_join(indicator_df_f, by = c("NUTS_ID" = "NUTS_ID")) |> 
  dplyr::select(-NUTS_NAME) |> 
  dplyr::filter(nchar(NUTS_ID) != 2)

Eurostat_GFCF_n <- Eurostat_GFCF |> 
  mutate(GFCF = (GFCF - min(GFCF, na.rm = TRUE)) / (max(GFCF, na.rm = TRUE) - min(GFCF, na.rm = TRUE)))

Sector_ID <- c("C", "C10-C12", "C13-C15", "C16-C18", "C19-C22", "C23", 
               "C24", "C25+C28-C30", "C26-C27", "C31-C32", "C33")

Eurostat_GFCF_n <- Eurostat_GFCF_n |> 
  tidyr::crossing(Sector_ID) |> 
  select(NUTS_ID, Sector_ID, everything())

# Save each dataset to an Excel file
writexl::write_xlsx(Eurostat_GFCF, "Outputs/Data/Eurostat_GFCF.xlsx")
writexl::write_xlsx(Eurostat_GFCF_n, "Outputs/Data/Eurostat_GFCF_n.xlsx")

# Return the paths of the saved files
return(c(
  "Outputs/Data/Eurostat_GFCF.xlsx",
  "Outputs/Data/Eurostat_GFCF_n.xlsx",
  "Outputs/Data/Eurostat_Fin.xlsx",
  "Outputs/Data/Eurostat_Fin_n.xlsx"
))


