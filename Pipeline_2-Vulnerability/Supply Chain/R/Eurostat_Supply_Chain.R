# Set working directory
setwd("/Users/giocopp/Desktop/LOCALISED-7.1-Paper/Pipeline_2-Vulnerability/Supply Chain")

### Install Necessary Packages ###
remotes::install_github("eurostat/restatapi")

libs <- c(
  "restatapi",
  "tidyverse",
  "giscoR",
  "sf",
  "classInt",
  "mice",
  "visdat",
  "VIM"
)

installed_libs <- libs %in% rownames(
  installed.packages()
)

if (any(installed_libs == FALSE)) {
  install.packages(
    libs[!installed_libs],
    dependencies = TRUE
  )
}

invisible(
  lapply(
    libs, library,
    character.only = TRUE
  )
)

### GET DATA
### 
### Unemployment

indicator_df <- restatapi::get_eurostat_data(
  id = "ext_tec09",
  filters = c("WORLD", "TOTAL", "C10", "C11", "C12", "C13", "C14", "C15", "C16", "C17", "C18", "C19", "C20", "C21", "C22", "C23", "C24", "C25", "C26", "C27", "C28", "C29", "C30", "C31", "C32", "C33", "IMP", "EXP", "THS_EUR"), 
  date_filter = c(2022, 2021),
  exact_match = T,
  label = F,
  cflags = T,
  keep_flags = T,
  verbose = T
)

indicator_df_f <- indicator_df |> 
  dplyr::rename(
    "NUTS_ID" = "geo",
    "Values" = "values",
    "Sector" = "nace_r2",
    "Stk_Flow" = "stk_flow",
    "Year" = "time"
  ) |> 
  dplyr::select(NUTS_ID, Sector, Year, Stk_Flow, Values)

# Load base data
base_data <- readxl::read_excel("/Users/giocopp/Desktop/LOCALISED-7.1-Paper/Base Data/base_data.xlsx") |> 
  dplyr::select(1, 3) |> 
  dplyr::filter(stringr::str_length(NUTS_ID) == 2)

Eurostat_Imp_Exp <- base_data |> 
  dplyr::left_join(indicator_df_f, by = "NUTS_ID") |> 
  dplyr::select(-NUTS_NAME)

# Impute missing 2022 values with 2021 data
Eurostat_Imp_Exp <- Eurostat_Imp_Exp |> 
  dplyr::group_by(NUTS_ID, Sector, Stk_Flow) |> 
  dplyr::mutate(
    Values = ifelse(Year == 2022 & is.na(Values), Values[Year == 2021], Values)
  ) |> 
  dplyr::ungroup()

### Handle Missing Values ###
# Transform data to wide format
data_wide <- Eurostat_Imp_Exp %>%
  tidyr::pivot_wider(
    names_from = Sector,
    values_from = Values
  )

# Inspect missing values
missing_summary <- data_wide %>%
  dplyr::summarise(across(everything(), ~ sum(is.na(.)), .names = "missing_{col}"))
missing_percentage <- data_wide %>%
  dplyr::summarise(across(everything(), ~ mean(is.na(.)) * 100, .names = "pct_missing_{col}"))

# Prepare data for imputation
data_for_imp <- data_wide %>%
  dplyr::select(-NUTS_ID, -Year, -Stk_Flow)

# Visualize Missing Data
vis_miss(data_for_imp)
VIM::aggr(data_for_imp, col = c("skyblue", "red"), numbers = TRUE, sortVars = TRUE, 
          labels = names(data_for_imp), cex.axis = 0.7, gap = 3, 
          ylab = c("Missing data", "Pattern"))

# Scale the data to stabilize the range
data_for_imp_scaled <- data_for_imp %>%
  dplyr::mutate(across(everything(), ~ scale(.)))

# Save scaling attributes
scaled_means <- attr(data_for_imp_scaled, "scaled:center")
scaled_sds <- attr(data_for_imp_scaled, "scaled:scale")

# Handle columns with high missingness
high_na_cols <- colnames(data_for_imp_scaled)[colMeans(is.na(data_for_imp_scaled)) > 0.3]
data_for_imp_scaled <- data_for_imp_scaled %>%
  dplyr::mutate(across(all_of(high_na_cols), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))

# Ensure columns are numeric after scaling
data_for_imp_scaled <- data_for_imp_scaled %>%
  dplyr::mutate(across(everything(), as.numeric))

### Perform MICE Imputation ###
imputed <- mice(
  data_for_imp_scaled,
  method = "pmm",  # Predictive Mean Matching
  m = 5,
  maxit = 50,
  seed = 123,
  printFlag = TRUE
)

# Extract completed dataset
data_imputed <- complete(imputed, 1)

# Reverse Scaling to Original Values
data_imputed_original <- data_imputed %>%
  dplyr::mutate(across(everything(), ~ . * scaled_sds[cur_column()] + scaled_means[cur_column()]))

# Combine with non-numeric columns
Eurostat_Imp_Exp <- bind_cols(
  data_for_imp %>% dplyr::select(-where(is.numeric)),  # Non-numeric columns
  data_imputed_original
)

# Verify no missing values remain
sum(is.na(Eurostat_Imp_Exp))  # Should return 0


# Convert back to long format
Eurostat_Imp_Exp <- data_wide_final %>%
  pivot_longer(
    cols = -c(NUTS_ID, Year, Stk_Flow),  # Keep these columns as is
    names_to = "Sector",                 # Column name for the sector variable
    values_to = "Values"                 # Column name for the imputed values
  )


# Save the updated dataset for NEETs
writexl::write_xlsx(
  Eurostat_neets,
  "Outputs/Data/Eurostat_neets.xlsx"
)

return(list(
  "Eurostat_unempl_rate.xlsx",
  "Eurostat_lab_m_slack.xlsx",
  "Eurostat_gdp.xlsx",
  "Eurostat_thw.xlsx",
  "Eurostat_neets.xlsx"
))


