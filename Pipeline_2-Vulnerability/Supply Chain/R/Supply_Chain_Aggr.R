setwd("/Users/giocopp/Desktop/LOCALISED-7.1-Paper/Pipeline_2-Vulnerability/Supply Chain")

### Read
library(readxl)

# Define the directory for outputs
output_dir <- "Outputs/Data"

# Read the Excel files
Eurostat_Exp <- read_excel(file.path(output_dir, "Eurostat_Exp.xlsx"))
Eurostat_Imp <- read_excel(file.path(output_dir, "Eurostat_Imp.xlsx"))
Eurostat_Rail <- read_excel(file.path(output_dir, "Eurostat_Rail.xlsx"))
RCI_rtp <- read_excel(file.path(output_dir, "RCI_rtp.xlsx"))
base_data <- read_excel("~/Desktop/LOCALISED-7.1-Paper/Base Data/base_data_plus.xlsx")

# Raw data aggreagation:
# 
national_data <- Eurostat_Exp |>
  dplyr::full_join(Eurostat_Imp, by = c("NUTS_ID", "Sector")) |>
  dplyr::mutate(Country_ID = substr(NUTS_ID, 1, 2))  # Extract Country ID

# Step 2: Prepare Regional-Level Data (Eurostat_Road, Eurostat_Rail, RCI_rtp)
regional_data <- Eurostat_Rail |>
  dplyr::full_join(RCI_rtp, by = c("NUTS_ID" = "RCI_code"))

# Step 3: Expand Regional Data to Include All Sectors
expanded_regional_data <- base_data |>
  dplyr::select(NUTS_ID) |>  # Get all regional codes
  dplyr::distinct() |> 
  tidyr::crossing(Sector = unique(national_data$Sector)) |>  # Create combinations
  dplyr::left_join(regional_data, by = "NUTS_ID") |>  # Add regional-level data
  dplyr::mutate(
    across(c(RL_Net, RT_Perf), ~ replace_na(.x, 0))  # Replace NAs with 0
  )

# Step 4: Combine National and Regional Data
final_data <- expanded_regional_data |>
  dplyr::mutate(Country_ID = substr(NUTS_ID, 1, 2)) |>  # Extract country ID from NUTS_ID
  dplyr::left_join(national_data, by = c("Country_ID" = "NUTS_ID", "Sector"))  # Join by country and sector

# Final Dataset: Ensure Desired Columns
SupCh_raw <- final_data |>
  dplyr::select(NUTS_ID, Sector, Exp, Imp, RL_Net, RT_Perf) |>
  dplyr::filter(stringr::str_length(NUTS_ID) != 2)

writexl::write_xlsx(
  SupCh_raw,
  "Outputs/Data/SupCh_raw.xlsx")

rm(national_data, expanded_regional_data, final_data)


### NORMALISE
### Function to normalize a data frame using min-max normalization
normalize_min_max <- function(df) {
  as.data.frame(lapply(df, function(col) {
    if (is.numeric(col)) {
      # Min-max normalization for numeric columns
      (col - min(col, na.rm = TRUE)) / (max(col, na.rm = TRUE) - min(col, na.rm = TRUE))
    } else {
      # Leave non-numeric columns as is
      col
    }
  }))
}

normalize_min_max_special <- function(data) {
  # Identify the numeric column dynamically
  numeric_cols <- sapply(data, is.numeric)
  col_to_normalize <- names(data)[numeric_cols]
  
  if (length(col_to_normalize) != 1) {
    stop("The function expects exactly one numeric column to normalize.")
  }
  
  col_to_normalize <- col_to_normalize[1] # Select the numeric column
  
  # Identify total manufacturing sector (C) and subsectors
  is_total_sector <- data$Sector == "C"
  is_subsector <- startsWith(data$Sector, "C") & data$Sector != "C"
  
  # Extract values for total sector C
  total_values <- data[[col_to_normalize]][is_total_sector]
  
  # Extract values for subsectors
  subsector_values <- data[[col_to_normalize]][is_subsector]
  
  # Compute min and max for total sector C
  min_C <- min(total_values, na.rm = TRUE)
  max_C <- max(total_values, na.rm = TRUE)
  
  # Compute min and max for all subsector values combined
  min_sub <- min(subsector_values, na.rm = TRUE)
  max_sub <- max(subsector_values, na.rm = TRUE)
  
  # Normalize total sector C values
  data[[col_to_normalize]][is_total_sector] <- (data[[col_to_normalize]][is_total_sector] - min_C) /
    (max_C - min_C)
  
  # Normalize subsector values across all subsectors
  data[[col_to_normalize]][is_subsector] <- (data[[col_to_normalize]][is_subsector] - min_sub) /
    (max_sub - min_sub)
  
  return(data)
}

# Apply normalization to all datasets
Eurostat_Exp <- normalize_min_max_special(Eurostat_Exp)
Eurostat_Imp <- normalize_min_max_special(Eurostat_Imp)
Eurostat_Rail <- normalize_min_max(Eurostat_Rail)
RCI_rtp <- normalize_min_max(RCI_rtp)

### Merge
# Step 1: Prepare National-Level Data (Eurostat_Exp and Eurostat_Imp)
national_data <- Eurostat_Exp |>
  dplyr::full_join(Eurostat_Imp, by = c("NUTS_ID", "Sector")) |>
  dplyr::mutate(Country_ID = substr(NUTS_ID, 1, 2))  # Extract Country ID

# Step 2: Prepare Regional-Level Data (Eurostat_Road, Eurostat_Rail, RCI_rtp)
regional_data <- Eurostat_Rail |>
  dplyr::full_join(RCI_rtp, by = c("NUTS_ID" = "RCI_code"))

# Step 3: Expand Regional Data to Include All Sectors
expanded_regional_data <- base_data |>
  dplyr::select(NUTS_ID) |>  # Get all regional codes
  dplyr::distinct() |> 
  tidyr::crossing(Sector = unique(national_data$Sector)) |>  # Create combinations
  dplyr::left_join(regional_data, by = "NUTS_ID") |>  # Add regional-level data
  dplyr::mutate(
    across(c(RL_Net, RT_Perf), ~ replace_na(.x, 0))  # Replace NAs with 0
  )

# Step 4: Combine National and Regional Data
final_data <- expanded_regional_data |>
  dplyr::mutate(Country_ID = substr(NUTS_ID, 1, 2)) |>  # Extract country ID from NUTS_ID
  dplyr::left_join(national_data, by = c("Country_ID" = "NUTS_ID", "Sector"))  # Join by country and sector

# Final Dataset: Ensure Desired Columns
SupCh_Index <- final_data |>
  dplyr::select(NUTS_ID, Sector, Exp, Imp, RL_Net, RT_Perf) |>
  dplyr::filter(stringr::str_length(NUTS_ID) != 2)

### Invert indicators that have negative relationship with vulnerability
SupCh_Index <- SupCh_Index |>
  dplyr::mutate(
    RL_Net = 1 - RL_Net,
    RT_Perf = 1 - RT_Perf
  )

###
### Calculate Sup Ch Index

# Function to calculate geometric mean of selected columns
calculate_geometric_mean <- function(x) {
  exp(mean(log(x[x > 0]), na.rm = TRUE))  # log transform and calculate mean, then exponentiate
}

# Apply the function to each row for the selected columns
SupCh_Index <- SupCh_Index %>%
  dplyr::mutate(Sup_Ch_Index = apply(SupCh_Index[, c("Exp", "Imp", "RL_Net", "RT_Perf")], 1, calculate_geometric_mean))

normalize_SupCh_Index <- function(data) {
  # Only normalize the Sup_Ch_Index column
  col_to_normalize <- "Sup_Ch_Index"
  
  # Identify total manufacturing sector (C) and subsectors
  is_total_sector <- data$Sector == "C"
  is_subsector <- startsWith(data$Sector, "C") & data$Sector != "C"
  
  # Extract values for total sector C
  total_values <- data[[col_to_normalize]][is_total_sector]
  
  # Extract values for subsectors
  subsector_values <- data[[col_to_normalize]][is_subsector]
  
  # Compute min and max for total sector C
  min_C <- min(total_values, na.rm = TRUE)
  max_C <- max(total_values, na.rm = TRUE)
  
  # Compute min and max for all subsector values combined
  min_sub <- min(subsector_values, na.rm = TRUE)
  max_sub <- max(subsector_values, na.rm = TRUE)
  
  # Normalize total sector C values
  data[[col_to_normalize]][is_total_sector] <- (data[[col_to_normalize]][is_total_sector] - min_C) /
    (max_C - min_C)
  
  # Normalize subsector values across all subsectors
  data[[col_to_normalize]][is_subsector] <- (data[[col_to_normalize]][is_subsector] - min_sub) /
    (max_sub - min_sub)
  
  return(data)
}

# Apply the normalization function to normalize the Sup_Ch_Index column
SupCh_Index_Norm <- normalize_SupCh_Index(SupCh_Index)

SupCh_Index_Norm <- SupCh_Index_Norm |> 
  rename("Sector_ID" = "Sector") |> 
  dplyr::mutate(
    SupCh = apply(SupCh_Index_Norm[, c("Exp", "Imp")], 1, calculate_geometric_mean),
    Tran_Net = apply(SupCh_Index_Norm[, c("RL_Net", "RT_Perf")], 1, calculate_geometric_mean)
  )

writexl::write_xlsx(
  SupCh_Index_Norm,
  "Outputs/Data/SupCh_Index.xlsx")

return("Outputs/Data/SupCh_Index.xlsx")
return("Outputs/Data/SupCh_raw.xlsx")
