setwd("/Users/giocopp/Desktop/LOCALISED-7.1-Paper/Pipeline_2-Vulnerability/Supply Chain")

### Read
library(readxl)

# Define the directory for outputs
output_dir <- "Outputs/Data"

# Read the Excel files
Eurostat_Exp <- read_excel(file.path(output_dir, "Eurostat_Exp.xlsx"))
Eurostat_Imp <- read_excel(file.path(output_dir, "Eurostat_Imp.xlsx"))
Eurostat_Rail <- read_excel(file.path(output_dir, "Eurostat_Rail.xlsx"))
RCI_rtp <- read_excel(file.path(output_dir, "RCI_rtp.xlsx"))
base_data <- read_excel("~/Desktop/LOCALISED-7.1-Paper/Base Data/base_data_plus.xlsx")

# Raw data aggreagation:
# 
national_data <- Eurostat_Exp |>
  dplyr::full_join(Eurostat_Imp, by = c("NUTS_ID", "Sector")) |>
  dplyr::mutate(Country_ID = substr(NUTS_ID, 1, 2))  # Extract Country ID

# Step 2: Prepare Regional-Level Data (Eurostat_Road, Eurostat_Rail, RCI_rtp)
regional_data <- Eurostat_Rail |>
  dplyr::full_join(RCI_rtp, by = c("NUTS_ID" = "RCI_code"))

# Step 3: Expand Regional Data to Include All Sectors
expanded_regional_data <- base_data |>
  dplyr::select(NUTS_ID) |>  # Get all regional codes
  dplyr::distinct() |> 
  tidyr::crossing(Sector = unique(national_data$Sector)) |>  # Create combinations
  dplyr::left_join(regional_data, by = "NUTS_ID") |>  # Add regional-level data
  dplyr::mutate(
    across(c(RL_Net, RT_Perf), ~ replace_na(.x, 0))  # Replace NAs with 0
  )

# Step 4: Combine National and Regional Data
final_data <- expanded_regional_data |>
  dplyr::mutate(Country_ID = substr(NUTS_ID, 1, 2)) |>  # Extract country ID from NUTS_ID
  dplyr::left_join(national_data, by = c("Country_ID" = "NUTS_ID", "Sector"))  # Join by country and sector

# Final Dataset: Ensure Desired Columns
SupCh_raw <- final_data |>
  dplyr::select(NUTS_ID, Sector, Exp, Imp, RL_Net, RT_Perf) |>
  dplyr::filter(stringr::str_length(NUTS_ID) != 2)

writexl::write_xlsx(
  SupCh_raw,
  "Outputs/Data/SupCh_raw.xlsx")

rm(national_data, expanded_regional_data, final_data)

### NORMALISE
### Function to normalize a data frame using min-max normalization
normalize_min_max <- function(df) {
  as.data.frame(lapply(df, function(col) {
    if (is.numeric(col)) {
      # Min-max normalization for numeric columns to range [0.01, 0.99]
      0.01 + (col - min(col, na.rm = TRUE)) / (max(col, na.rm = TRUE) - min(col, na.rm = TRUE)) * (0.99 - 0.01)
    } else {
      # Leave non-numeric columns as is
      col
    }
  }))
}

normalize_min_max_special <- function(data) {
  # Identify the numeric column dynamically
  numeric_cols <- sapply(data, is.numeric)
  col_to_normalize <- names(data)[numeric_cols]
  
  if (length(col_to_normalize) != 1) {
    stop("The function expects exactly one numeric column to normalize.")
  }
  
  col_to_normalize <- col_to_normalize[1] # Select the numeric column
  
  # Identify total manufacturing sector (C) and subsectors
  is_total_sector <- data$Sector == "C"
  is_subsector <- startsWith(data$Sector, "C") & data$Sector != "C"
  
  # Extract values for total sector C
  total_values <- data[[col_to_normalize]][is_total_sector]
  
  # Extract values for subsectors
  subsector_values <- data[[col_to_normalize]][is_subsector]
  
  # Compute min and max for total sector C
  min_C <- min(total_values, na.rm = TRUE)
  max_C <- max(total_values, na.rm = TRUE)
  
  # Compute min and max for all subsector values combined
  min_sub <- min(subsector_values, na.rm = TRUE)
  max_sub <- max(subsector_values, na.rm = TRUE)
  
  # Normalize total sector C values to [0.01, 0.99]
  data[[col_to_normalize]][is_total_sector] <- 0.01 + 
    (data[[col_to_normalize]][is_total_sector] - min_C) / (max_C - min_C) * (0.99 - 0.01)
  
  # Normalize subsector values to [0.01, 0.99]
  data[[col_to_normalize]][is_subsector] <- 0.01 + 
    (data[[col_to_normalize]][is_subsector] - min_sub) / (max_sub - min_sub) * (0.99 - 0.01)
  
  return(data)
}

# Apply normalization to all datasets
Eurostat_Exp <- normalize_min_max_special(Eurostat_Exp)
Eurostat_Imp <- normalize_min_max_special(Eurostat_Imp)
Eurostat_Rail <- normalize_min_max(Eurostat_Rail)
RCI_rtp <- normalize_min_max(RCI_rtp)

### Merge### Merge### Merge
# Step 1: Prepare National-Level Data (Eurostat_Exp and Eurostat_Imp)
national_data <- Eurostat_Exp |>
  dplyr::full_join(Eurostat_Imp, by = c("NUTS_ID", "Sector")) |>
  dplyr::mutate(Country_ID = substr(NUTS_ID, 1, 2))  # Extract Country ID

# Step 2: Prepare Regional-Level Data (Eurostat_Road, Eurostat_Rail, RCI_rtp)
regional_data <- Eurostat_Rail |>
  dplyr::full_join(RCI_rtp, by = c("NUTS_ID" = "RCI_code"))

# Step 3: Expand Regional Data to Include All Sectors
expanded_regional_data <- base_data |>
  dplyr::select(NUTS_ID) |>  # Get all regional codes
  dplyr::distinct() |> 
  tidyr::crossing(Sector = unique(national_data$Sector)) |>  # Create combinations
  dplyr::left_join(regional_data, by = "NUTS_ID") |>  # Add regional-level data
  dplyr::mutate(
    across(c(RL_Net, RT_Perf), ~ replace_na(.x, 0))  # Replace NAs with 0
  )

# Step 4: Combine National and Regional Data
final_data <- expanded_regional_data |>
  dplyr::mutate(Country_ID = substr(NUTS_ID, 1, 2)) |>  # Extract country ID from NUTS_ID
  dplyr::left_join(national_data, by = c("Country_ID" = "NUTS_ID", "Sector"))  # Join by country and sector

# Final Dataset: Ensure Desired Columns
SupCh_Index <- final_data |>
  dplyr::select(NUTS_ID, Sector, Exp, Imp, RL_Net, RT_Perf) |>
  dplyr::filter(stringr::str_length(NUTS_ID) != 2)

### Invert indicators that have negative relationship with vulnerability
SupCh_Index <- SupCh_Index |>
  dplyr::mutate(
    RL_Net = 1 - RL_Net,
    RT_Perf = 1 - RT_Perf
  )

# We exclude RT Performance
SupCh_Index <- SupCh_Index |>
  dplyr::select(-RT_Perf)

# Calculate SupCh and Tran_Net with geometric means
SupCh_Index <- SupCh_Index |> 
  rename("Sector_ID" = "Sector") |> 
  dplyr::mutate(
    SupCh = apply(SupCh_Index[, c("Exp", "Imp")], 1, function(row) {
      weights <- c(0.5, 0.5)
      positive_values <- row[row > 0]
      normalized_weights <- weights[row > 0] / sum(weights[row > 0])
      exp(sum(log(positive_values) * normalized_weights, na.rm = TRUE))
    }),
    Tran_Net = apply(SupCh_Index[, c("RL_Net")], 1, function(row) {
      weights <- c(0.5, 0.5)
      positive_values <- row[row > 0]
      normalized_weights <- weights[row > 0] / sum(weights[row > 0])
      exp(sum(log(positive_values) * normalized_weights, na.rm = TRUE))
    })
  )

# Calculate Sup_Ch_Index with a weighted geometric mean
SupCh_Index <- SupCh_Index %>%
  dplyr::mutate(
    Sup_Ch_Index = apply(SupCh_Index[, c("SupCh", "Tran_Net")], 1, function(row) {
      weights <- c(0.5, 0.5)
      positive_values <- row[row > 0]
      normalized_weights <- weights[row > 0] / sum(weights[row > 0])
      exp(sum(log(positive_values) * normalized_weights, na.rm = TRUE))
    })
  )

# Normalize Sup_Ch_Index
normalize_SupCh_Index <- function(data) {
  col_to_normalize <- "Sup_Ch_Index"
  
  # Identify groups
  is_total_sector <- data$Sector_ID == "C"
  is_subsector <- startsWith(data$Sector_ID, "C") & data$Sector_ID != "C"
  
  # Min-max normalization for total sector C
  min_C <- min(data[[col_to_normalize]][is_total_sector], na.rm = TRUE)
  max_C <- max(data[[col_to_normalize]][is_total_sector], na.rm = TRUE)
  data[[col_to_normalize]][is_total_sector] <- 0.01 + 
    (data[[col_to_normalize]][is_total_sector] - min_C) / (max_C - min_C) * (0.99 - 0.01)
  
  # Min-max normalization for subsectors
  min_sub <- min(data[[col_to_normalize]][is_subsector], na.rm = TRUE)
  max_sub <- max(data[[col_to_normalize]][is_subsector], na.rm = TRUE)
  data[[col_to_normalize]][is_subsector] <- 0.01 + 
    (data[[col_to_normalize]][is_subsector] - min_sub) / (max_sub - min_sub) * (0.99 - 0.01)
  
  return(data)
}

# Apply normalization
SupCh_Index_Norm <- normalize_SupCh_Index(SupCh_Index)


writexl::write_xlsx(
  SupCh_Index_Norm,
  "Outputs/Data/SupCh_Index.xlsx")

View(SupCh_Index_Norm)

return("Outputs/Data/SupCh_Index.xlsx")
return("Outputs/Data/SupCh_raw.xlsx")
